<div id="articleheader">
  <h2 id="articletitle">What I've Learned About Recursion So Far [Racket]</h2>
  <p id="articledate">Published June 19, 2018</p>
</div>
<div id="articlecontent">
  <p>My <em>Intro to Computer Science</em> class has now officially drawn to a close, and I wanted to make a post on one of the core concepts taught in that class: recursion. A significant amount of my classmates struggled with recursion, and I had to have a few eurekas before understanding it at the level the class demanded. In this post, I would like to articulate how I view recursion and how it structures itself in my mind. I’ll be using Racket as my language for this post as it’s currently the language I am most comfortable with, but the most important part of understanding recursion is not the language, but how it works. What you learn about recursion in one language can largely be applied to any other language. Let’s get started.</p>
  <br />
  <p class="disclaimer"><strong>DISCLAIMER:&nbsp;</strong><em>I am still very much a beginner to programming, so do keep in mind that while my code may work, it may not follow good coding practices or be very efficient. If you would like some help in finding educational resources, check out the /r/learnprogramming subreddit wiki <a href="https://www.reddit.com/r/learnprogramming/wiki/faq" target="_blank">[here]</a>. While I still have your attention, [<a href="https://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources" target="_blank">here</a>] is a list of resources discouraged by /r/learnprogramming either due to unreliable or misleading information.</em></p>
  <br />
  <h2>What is <a href="/post.html?postid=20180619a" class="nodecor">Recursion</a>?</h2>
  <p>In a general sense, <strong>recursion</strong> is calling a function while defining the function. In other words, let’s say that I wanted to create a function called A. I would then proceed to use A inside of its own definition. When I was first taught this, my immediate thought was, “God dammit”, followed shortly after by “How could you use a function in its own definition? It hasn’t been defined yet.” I imagined an infinite loop happening, where A would just call itself, which would then call A again, which would then call A again, and then A again, and then A, and A, and A, A, A, A, A, A …</p>
  <p><img class="center" src="https://i0.wp.com/i.imgur.com/PVKVl9g.png?resize=956%2C478&amp;ssl=1" width="691" height="345"></p>
  <p>It turns out that this loop does happen, but it’s not infinite, and at some point A doesn’t call itself and instead returns some sort of value. This is called the <strong>termination condition</strong>. The best way to illustrate this, of course, is to simply show you the code. Suppose we would like to create a factorial function, which simply takes a non-negative number&nbsp;<em>n</em> and calculates&nbsp;<em>n * (n – 1) * (n – 2) * . . . 1</em>. So 5! (for those who do not know, ! denotes a factorial) would be equal to 5 * 4 * 3 * 2 * 1, or 120. 2! would simply be 2 * 1, or 2, and 1! is simply 1. The only exception to this rule is that 0! is equal to 1, the reasoning for which can be found [<a href="https://zero-factorial.com/whatis.html" target="_blank">here</a>].</p>
  <br />
  <p>If I wanted to execute&nbsp;<em>(factorial 5)</em>, the math inside of the definition could be <em>n * (n – 1) * (n – 2) * (n – 3) * (n – 4).&nbsp;</em>However, this of course wouldn’t work with any number but 5. If I did (<em>factorial</em><em>&nbsp;7)</em> using the aforementioned equation, then the answer provided would be equal to 7 * 6 * 5 * 4 * 3, which would be incorrect. In other words, we would run into an issue where we don’t know when to stop subtracting from&nbsp;<em>n</em> and when to keep subtracting from&nbsp;<em>n</em>.</p>
  <br />
  <p>To get us started with recursion, remember that n! is equivalent to <em>n * (n – 1)!</em>. So&nbsp;<em>5!&nbsp;</em>is equal to&nbsp;<em>5 * 4!</em>, which would in turn be equal to&nbsp;<em>5 * 4 * 3!</em>. So maybe the code for factorial would look something like this:</p>
  <p><script src="https://pastebin.com/embed_js/gTmUnfHW/noheader"></script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; factorial: Number -&gt; Number</div></li><li class="li1"><div class="de1">; Receives a number and reports the factorial value of it.</div></li><li class="li1"><div class="de1">(define (factorial n)</div></li><li class="li1"><div class="de1">&nbsp; (* n (factorial (sub1 n))))</div></li></ol></div><p></p>
  <p>However, if we run&nbsp;<em>(factorial 5)</em>, we run out of memory. This is because there is no termination step. In other words, when running our current&nbsp;<em>factorial</em> function, it tries to calculate&nbsp;<em>(factorial 5)</em>, which then calls for&nbsp;<em>(factorial 4)</em>, which then calls for&nbsp;<em>(factorial 3)</em>, and&nbsp;<em>(factorial 2)</em>,&nbsp;and&nbsp;<em>(factorial 1)</em>, and&nbsp;<em>(factorial 0)</em> and then it goes into the negatives with&nbsp;<em>(factorial -1)&nbsp;</em>and so on and so forth. Because there isn’t anything telling the function when to stop, then it just keeps subtracting 1 from&nbsp;<em>n</em> and then calls&nbsp;<em>factorial</em> on that value. So we need to add a termination step:</p>
  <p><script src="https://pastebin.com/embed_js/S3kUnMvE/noheader">﻿</script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; factorial: Number -&gt; Number</div></li><li class="li1"><div class="de1">; Receives a number and reports the factorial value of it.</div></li><li class="li1"><div class="de1">(define (factorial n)</div></li><li class="li1"><div class="de1">&nbsp; (cond</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; [(zero? n) 1]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; [else (* n (factorial (sub1 n)))]))</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">(check-expect (factorial 0) 1)</div></li><li class="li1"><div class="de1">(check-expect (factorial 1) 1)</div></li><li class="li2"><div class="de2">(check-expect (factorial 3) 6)</div></li><li class="li1"><div class="de1">(check-expect (factorial 5) 120)</div></li></ol></div><p></p>
  <p><img class="center" src="https://i2.wp.com/i.imgur.com/4FvEtxG.png?resize=622%2C440&amp;ssl=1" width="622" height="440"></p>
  <p>Now, when we run&nbsp;<em>(factorial</em>&nbsp;<em>5)</em>, it first checks if the given input, 5, is 0. If not, then it multiplies 5 by the value of <em>(factorial 4).</em>&nbsp;<em>Factorial</em> then checks if 4 is 0, which it isn’t, so it multiples 4 by the value of&nbsp;<em>(factorial 3)</em>. This continues until we reach&nbsp;<em>(factorial 0)</em>, which returns 1 because the first condition is satisfied. The value 1 is then returned to&nbsp;<em>(factorial 1)</em>, the function that called&nbsp;<em>(factorial 0)</em>, which calculates&nbsp;<em>1 * (factorial 0) = 1 * 1 = 1.&nbsp;&nbsp;</em>This is returned to <em>(factorial</em> 2), which calculates <em>2 * (factorial 1) = 2 * 1 = 2.</em> This goes all the way back up to <em>(factorial 5)</em>, which would return 120. And when the above code is run, all the <em>check-expects</em> pass (<em>check-expect</em> works by comparing a given expression to an expected value. If the value of the given expression is equal to the expected value, it returns true, otherwise it returns false).</p>
  <p><img class="center" src="https://i2.wp.com/i.imgur.com/c02PZJq.png?resize=668%2C442&amp;ssl=1" width="668" height="442"></p>
  <p>This type of recursion is very similar to structural recursion, or recursion that follows a specific structure, which is one of the three different types of recursion I learned in my <em>Intro to Computer Science</em> class.</p>
  <p><strong>Types of Recursion:</strong></p>
  <ul>
    <li>Structural Recursion</li>
    <li>Generative Recursion</li>
    <li>Accumulative Recursion</li>
  </ul>
  <p>I’ve noticed that some of my friends in Computer Science have not heard of these terms before, but are aware of the concept, so you may have heard of these concepts under a different name. In any case, the concept is what is important.</p>
  <br />
  <h2>Structural Recursion</h2>
  <p>We’ll of course go over all three of these types in this post. Let’s finish up talking about structural recursion though. Generally speaking, structural recursion is the consequence of a recursive data definition. What does that mean? Well, in the Racket language, you can create lists. If you look at the data definition for a list, it goes something along the lines of:</p>
  <p><script src="https://pastebin.com/embed_js/kaGfCJxA/noheader">﻿</script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; A [ListOf X] is one of:</div></li><li class="li1"><div class="de1">; - empty</div></li><li class="li1"><div class="de1">; - (cons X [ListOf X])</div></li></ol></div><p></p>
  <p>(<em>Cons&nbsp;</em>is a function that takes a datatype and a list and adds the datatype to the beginning of the list).</p>
  <p>This data definition is a bit odd, because I use <em>[ListOf X]</em> in its own data definition. It is, after all, a&nbsp;<em>recursive</em> data definition. The data definition for&nbsp;<em>[ListOf X]</em> allows for me to create a list of arbitrary size. If I wanted an empty list, then <em>[ListOf X]</em> would simply be empty, which is one of the choices for&nbsp;<em>[ListOf X]</em>. Otherwise,&nbsp;<em>[ListOf X]</em> is an&nbsp;<em>X&nbsp;</em>that is being&nbsp;<em>cons</em>‘d onto a&nbsp;<em>[ListOf X]</em>. Because&nbsp;<em>cons</em> accepts any datatype for the first parameter but demands a list for the second parameter, this works out perfectly.&nbsp;<em>X</em> is the datatype desired for the first parameter and&nbsp;<em>[ListOf X]</em> is a list, which satisfies the requirements for the second parameter. Let’s go over some examples to better highlight this concept:</p>
  <p><script src="https://pastebin.com/embed_js/kXWUgVB4/noheader"></script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">(check-expect empty empty)</div></li><li class="li1"><div class="de1">(check-expect (list 1) (cons 1 empty))</div></li><li class="li1"><div class="de1">(check-expect (list 1 2) (cons 1 (cons 2 empty)))</div></li><li class="li1"><div class="de1">(check-expect (list 1 2 3) (cons 1 (cons 2 (cons 3 empty))))</div></li><li class="li2"><div class="de2">&nbsp;</div></li><li class="li1"><div class="de1">(define list1 empty)</div></li><li class="li1"><div class="de1">(define list2 (cons 3 list1))</div></li><li class="li1"><div class="de1">(define list3 (cons 2 list2))</div></li><li class="li1"><div class="de1">(define list4 (cons 1 list3))</div></li><li class="li2"><div class="de2">(check-expect (list 1 2 3) list4)</div></li></ol></div><p></p>
  <p>The&nbsp;<em>check-expects</em> above all pass, and you can clearly see how&nbsp;<em>cons</em> works with the examples. In the first set of&nbsp;<em>check-expects</em>, you can see how I&nbsp;<em>cons</em> the first variable onto either an&nbsp;<em>empty</em> or another&nbsp;<em>cons</em>. This is because&nbsp;<em>cons&nbsp;</em>requires a list as its second parameter. If I’m not&nbsp;<em>cons</em>ing onto an&nbsp;<em>empty</em> (which is still a list, albeit an empty one) then I&nbsp;must be&nbsp;<em>cons</em>ing onto another non-empty list, which is created by the following&nbsp;<em>cons</em>es.</p>
  <p>The second set of&nbsp;<em>check-expects</em> essentially illustrate the fact that&nbsp;<em>cons</em> demands that its second parameter is a list. I defined various variables (<em>ha various variables</em>) as lists, and in each definition, I would&nbsp;<em>cons</em> a number to the list before it. This will be easier to explain with a graphic:</p>
  <p><img class="center" src="https://i0.wp.com/i.imgur.com/qUot9Sb.png?ssl=1" width="675" height="382"></p>
  <p>So what would be an example of structural recursion applied to this recursive datatype? For this, let’s take my final exam!</p>
  <br />
  <p>My final exam essentially asked us to take the same problem and solve it using structural recursion, generative recursion, and accumulative recursion. Which is perfect for this blog topic. The exam asked us to take a list of numbers and calculate the sum. So first, time to solve this question with structural recursion.</p>
  <p>We would want the program to essentially take the first number, add the second number, add the third number, all the way to the end. Thinking recursively, this is also like saying take the first number and add it to the sum of the rest of the list not including the first number. In other words, finding the sum of&nbsp;<em>(list 1 2 3)</em> is the same as finding the sum of&nbsp;<em>(list</em> <em>2 3)</em> and adding 1 to it. We’ll need a termination condition as well, something that tells the function when to stop going down the list. For us, this is&nbsp;when the list is empty.<br>
  <script src="https://pastebin.com/embed_js/TeHzeJSb/noheader">﻿</script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; structural-sum: [ListOf Number] -&gt; Number</div></li><li class="li1"><div class="de1">; Calculates the sum of the numbers in a given list of numbers using structural recursion.</div></li><li class="li1"><div class="de1">(define (structural-sum lon)</div></li><li class="li1"><div class="de1">&nbsp; (cond</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; [(empty? lon) 0]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; [else (+ (first lon) (structural-sum (rest lon)))]))</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">(check-expect (structural-sum empty) 0)</div></li><li class="li1"><div class="de1">(check-expect (structural-sum (list 1)) 1)</div></li><li class="li2"><div class="de2">(check-expect (structural-sum (list 1 2)) 3)</div></li><li class="li1"><div class="de1">(check-expect (structural-sum (list 1 2 3)) 6)</div></li></ol></div><p></p>
  <p>With this, the first condition is our termination step (we want the function to check if the given input matches the termination condition first before it moves on to the rest of the code). If the list is empty, return 0. This makes sense; once we get to the end of the list, we want the function to stop running and work its way back up. 0 effectively acts as a way for us to stop the function from running without adding anything to the list.&nbsp; Furthermore, this gives us a way to deal with the case in which the function is given an empty list. If the function is given an empty list, 0 is a good representation of the sum of the list.</p>
  <p>If the list is not empty, then we want the function to take the first item of the list and add it to the recursively called function that finds the sum of the rest of the list. This matches what we mentioned two paragraphs ago. I’ll do one more graphic to help explain how this works, but its best to avoid completely visualizing how the recursion works all the way to the termination case. My TA taught me that I should “trust in the recursion” and assume it works. In other words, if you’ve covered your termination case(s), then your recursion should work, so don’t think too deeply about it. While this isn’t too applicable with simple recursion like this, this was a life-saver for me once I started dealing with more complicated recursions.</p>
  <p><img class="center" src="https://i2.wp.com/i.imgur.com/a7WFVel.png?resize=573%2C404&amp;ssl=1" width="573" height="404"></p>
  <p>That should just about do it for structural recursion. Time to move on to generative recursion.</p>
  <br />
  <h2>Generative Recursion</h2>
  <p>Generative recursion, in essence, is recursion that does not necessarily follow a set structure. While functions using generative recursion still have termination cases, everything else can be drastically different from structural recursion. The way I was taught was that generative recursion is recursion that is built on a case-by-case basis. Generative recursion is more flexible, and you don’t follow set structure, but rather build the code based on the problem you are given.</p>
  <p><img class="center" src="https://i2.wp.com/i.imgur.com/EcULVNd.png?ssl=1" width="636" height="445"></p>
  <p>The best example of generative recursion is the iconic <em>mergesort</em>, an algorithm that sorts a given list by splitting the list in half, calling the <em>mergesort</em> function on each of the two halves, and then merging those results together.&nbsp; When I was first introduced to this, my mind was blown, so I’d like to review <em>mergesort</em> later. But first, let’s do the exam problem.</p>
  <p>The exam asked us to find the sum of a list by splitting the list in half and finding the sum of those two halves. In other words, it asked us to find the sum of the list using the same method demonstrated in mergesort.</p>
  <p>I’ve always viewed generative recursion as taking an idea for a solution that you’ve come up with and then translating it into code. So first, I’d like to visualize that idea. On the exam, I drew up a basic diagram to show my thought process:</p>
  <p><img class="center" src="https://i0.wp.com/i.imgur.com/OdabaWJ.png?resize=824%2C351&amp;ssl=1" width="691" height="294"></p>
  <p>This diagram essentially illustrates the following idea:</p>
  <ol>
    <li>Given a list&nbsp;<em>(list a b c d).</em></li>
    <li>Split the list in half (in this case two lists are created,&nbsp;<em>(list a b)&nbsp;</em>and&nbsp;<em>(list c d))</em>.</li>
    <li>Recursively do the same to the halves that are created.</li>
    <li>Stop when there is only one item in the list (this it the termination condition).</li>
  </ol>
  <p>Once we get to the termination condition, what should we do? I imagine it this way: if I were given a list of just one number and asked for the sum, what would I do? Well, I wouldn’t start pulling out addition or subtraction or multiplication or indemnification. I’d simply give them that number from the list. So that’s what our termination condition result will be. If the list only has one item, then return that one item.</p>
  <p>We’ll also have to create one more extra condition for if the list is empty. If the list is empty, the function should return 0, just as we mentioned earlier.</p>
  <p>The final condition covers the case that the list is not empty and also has more than one number in it; in that case, we would like to sum together the sum of the two halves. With all the conditions now planned out, we can begin typing our code based on what we’ve outlined.</p>
  <p>We need a way to split the list in half; there isn’t a function like&nbsp;<em>(half list)</em> or anything like that. We can do this by creating two helper functions,&nbsp;<em>take&nbsp;</em>and&nbsp;<em>drop</em>, which can be applied to the list.&nbsp;<em>Take&nbsp;</em>will take a given number of items from the front of the list and return the taken items. <em>D</em><em>rop</em> will drop a given number of items from the front of the list and return the remaining items. Then, all we need to do is take half of the list and drop half of the list to get our two halves!</p>
  <p><script src="https://pastebin.com/embed_js/cgUKLcRJ/noheader"></script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; generative-sum: [ListOf Number] -&gt; Number</div></li><li class="li1"><div class="de1">; Calculates the sum of a given list of numbers using generative recursion (mergesort method).</div></li><li class="li1"><div class="de1">(define (generative-sum lon)</div></li><li class="li1"><div class="de1">&nbsp; (local</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; [(define mid (/ (length lon) 2)) ; half the length of the list, the midpoint</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;; take: [ListOf X] Number -&gt; [ListOf X]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;; Takes a given number of items out of the front of a given list and returns a list of those taken items.</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;(define take (λ (lox amt)</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(empty? lox) empty] </div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; If the list is empty, then taking anything out of an empty list still results in an empty list.</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(&lt;= amt 0) empty] </div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; If the user asks to take 0 or less items out of a list, return an empty list.</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (cons (first lox) (take (rest lox) (sub1 amt)))]))) </div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Otherwise, cons the first item of the list to the result of taking (amount - 1) items from the rest of the list. Cons allows you to "take" the first item, and once you've taken one item, you can subtract 1 from the amount needed to be taken from the rest of the list.</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;; drop: [ListOf X] Number -&gt; [ListOf X]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;; Drops a given number of items out of the front of a given list and returns a list of the remaining items.</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp;(define drop (λ (lox amt)</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(empty? lox) empty] </div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; If the list is empty, then dropping anything out of an empty list still results in an empty list.</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(&lt;= amt 0) lox] </div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; If the user asks to drop 0 or less items out of a list, then nothing is dropped so return the full list.</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (drop (rest lox) (sub1 amt))]))) </div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Otherwise, call drop on the rest of the list and drop (amount - 1 items). This effectively drops the first item because don't keep the first item around using (first lox). Each time you drop an item, you subtract 1 from the amount needed to be dropped from the rest of the list.</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; (cond</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; [(empty? lon) 0]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; [(= (length lon) 1) (first lon)]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; [else (+ (generative-sum (take lon mid)) (generative-sum (drop lon mid)))])))</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">(check-expect (generative-sum empty) 0)</div></li><li class="li2"><div class="de2">(check-expect (generative-sum (list 1)) 1)</div></li><li class="li1"><div class="de1">(check-expect (generative-sum (list 1 2 3)) 6)</div></li><li class="li1"><div class="de1">(check-expect (generative-sum (list 1 2 3 4)) 10)</div></li></ol></div><p></p>
  <p>I’ve written out the explanation for&nbsp;<em>take</em> and&nbsp;<em>drop</em> in the comments of the code above, but if you want a more in-depth explanation, check out the spoiler below. Also for those that don’t know what&nbsp;λ (lambda) is, treat it as if I am creating the code for a function. In other words, (<em>define drop (λ (lon amt) … ))&nbsp;</em>is the same as saying&nbsp;<em>(define (drop lon amt)</em>&nbsp;<em>… ).&nbsp;</em>I might make a post on&nbsp;λ some other time.</p>
  <button type="button" class="collapsible" onclick="toggleCollapsible(this)">Explanation for Take and Drop</button>
  <div class="collapsiblecontent">
    <h3>Take</h3>
    <p>There is no function to simply grab a set amount of items from a list, but there is a way to take one item from the list, specifically the first item,&nbsp;<em>(first lox)</em>. We can use recursion to essentially take one item at a time, and once we’ve taken the desired amount of items, we can tell the function to stop taking items. So when do we know to stop taking items? We do this by adding a second parameter&nbsp;<em>amt</em>, which measures how much needs to be taken from the list. Each time we take an item out of the front of the list, we subtract one from the amount that needs to be taken and take that many from the rest of list.&nbsp;<em>Cons&nbsp;</em>allows us to save what we’ve taken.</p>
    <p>The proper way of thinking through this recursively is that taking x items from the front of the list is the same as attaching the first item of the list to the result of taking (x – 1) items from the rest of the list. For example, let’s say we want to take 3 items from (list 1 2 3 4 5). Taking 3 items from the list is the same as taking the first item, 1, and attaching it to the result of taking 2 items from the rest of the list. That’s essentially how the code for <em>take</em> works.</p>
    <br />
    <h3>Drop</h3>
    <p>The logic for&nbsp;<em>drop</em> is essentially the same as the logic for&nbsp;<em>take</em>. Whereas&nbsp;<em>(first lox)</em> acts as a way of extracting the first item of the list so that we can “take” the item,&nbsp;<em>(rest lox)</em> acts as a way for us to “delete” the first item of a list. And as with&nbsp;<em>take</em>, we can only drop one item at a time, so we create a second parameter that allows us to tell the function when to stop dropping variables.</p>
    <p></p>
  </div>
  <p></p>
  <p>With the helper function, we were able to successfully translate our idea into code, and given that all our&nbsp;<em>check-expects</em> passed, it looks like it worked! We set up the two conditions first; if the list is empty, return 0, and if the length of the list is 1 (i.e. it only has one item in it), then return that number using&nbsp;<em>(first lon)</em>. If the given input does not match any of those conditions, then recursively find the sum (using <em>generative-sum</em>) of the first half (retrieved by using&nbsp;<em>take</em> to take out half of the list, which is done using&nbsp;<em>mid</em>) and the sum of the second half (retrieved by using&nbsp;<em>drop</em> to drop half of the list) and add those two values together (using the + operator).&nbsp;</p>
  <p>One mistake I made when I was first learning this was trying to think everything through to the base case (the base case being the termination step). While I eventually could work it out, it took me forever and I got confused quite often along the way. And this was <em>mergesort</em>, which was pretty simple compared to some of the recursion I did later on in the class. I personally find that it’s better to simply trust that you properly coded the termination steps and to believe that the recursion will work. In other words, for our code above, when coding that last condition, it’s best to assume that <em>generative-sum</em> already works the way you want it to and then think “assuming this function already works, what would I like to do with the result?”. If we assume that <em>generative-sum</em> will take a list of numbers, those lists being the two halves, and return the sum of those numbers, then I would ideally like to then add those two sums together, which is what I did.</p>
  <br />
  <p>Now that we’ve finished coding the solution to finding the sum of a list of numbers using generative recursion, let’s review <em>mergesort</em>! <em>Mergesort</em> has the same two helper functions,&nbsp;<em>take&nbsp;</em>and&nbsp;<em>drop</em>, but also has one more additional helper function,&nbsp;<em>merge</em>. With our <em>generative-sum&nbsp;</em>equation, once we’ve split the list in half, then all we need to do is add together the two halves after the function has been recursively applied to them. However, with&nbsp;<em>mergesort</em>, we want to sort the list in some fashion (for this example, we’ll say we want to sort a list of numbers in ascending order), so we have to create a function that will properly combine the two halves.</p>
  <br />
  <p>The idea behind&nbsp;<em>merge</em> is that it will accept two lists and compare the first item of the first list to the first item of the second list. For our example, if the first item is less than than the second item, then we will keep the first item and apply&nbsp;<em>merge</em> to the rest of the first list and the entirety of the second list. But if the first item is greater than the second item, then we will keep second item instead and then apply&nbsp;<em>merge&nbsp;</em>to the entirety of the first list and the rest of the second list. This allows us to arrange everything in ascending order, as desired. Of course, if one of the lists is empty, then just return the other because there is nothing to sort or merge. The following depiction will help explain this better:</p>
  <p><img class="center" src="https://i1.wp.com/i.imgur.com/GE99Wmi.png?resize=997%2C312&amp;ssl=1" width="691" height="216"></p>
  <p>The two initial conditions will also change a little bit. If the list is empty, then we should return empty instead, because&nbsp;<em>mergesort</em> will accept a [ListOf Number] and then return another [ListOf Number] that has been sorted. As for the second condition, if the length of the list is one, then just simply return the list. With that in mind, the code should look a little something like this:</p>
  <p><script src="https://pastebin.com/embed_js/JLA1uA4H/noheader"></script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; merge-sort: [ListOf Number] -&gt; [ListOf Number]</div></li><li class="li1"><div class="de1">; Sorts a given list of numbers in ascending order by splitting the list in half.</div></li><li class="li1"><div class="de1">(define (merge-sort lon)</div></li><li class="li1"><div class="de1">&nbsp; (local</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; [(define mid (/ (length lon) 2))</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;(define take (λ (lox amt)</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(empty? lox) empty]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(&lt;= amt 0) empty]</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (cons (first lox) (take (rest lox) (sub1 amt)))])))</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;(define drop (λ (lox amt)</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(empty? lox) empty]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(&lt;= amt 0) lox]</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (drop (rest lox) (sub1 amt))])))</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp;(define merge (λ (lon1 lon2)</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[(empty? lon1) lon2]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[(empty? lon2) lon1]</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[(&lt;= (first lon1) (first lon2)) (cons (first lon1) (merge (rest lon1) lon2))]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[(&gt; (first lon1) (first lon2)) (cons (first lon2) (merge lon1 (rest lon2)))])))]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; (cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; [(empty? lon) empty]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; [(= (length lon) 1) lon]</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; &nbsp; [else (merge (merge-sort (take lon mid)) (merge-sort (drop lon mid)))])))</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">(check-expect (merge-sort empty) empty)</div></li><li class="li1"><div class="de1">(check-expect (merge-sort (list 1)) (list 1))</div></li><li class="li1"><div class="de1">(check-expect (merge-sort (list 5 3 2 -5 9)) (list -5 2 3 5 9))</div></li><li class="li2"><div class="de2">(check-expect (merge-sort (list 5 3 4 6 2 1)) (list 1 2 3 4 5 6))</div></li></ol></div><p></p>
  <p>Once again, when thinking about how this works, just remember to trust the recursion. It helps with comprehending it much better.</p>
  <br />
  <p>One thing to remember is that generative recursion will not necessarily follow&nbsp;<em>mergesort</em>‘s structure;&nbsp;<em>mergesort</em> is simply an example of generative recursion. Simply put, all&nbsp;<em>mergesort</em> is generative recursion, but not all generative recursion is&nbsp;<em>merge</em><em>sort.</em> Since generative recursion is recursion that doesn’t follow a set structure and is done on a case-by-case basis, one example of generative recursion can be drastically different from another. Alright, let’s move on to the final type of recursion I learned!</p>
  <br />
  <h2>Accumulative Recursion</h2>
  <p>With the recursion we’ve gone over so far, you may notice that in each of the diagrams, I go down what looks like a staircase and then come back up with each result:</p>
  <p><img class="center" src="https://i0.wp.com/i.imgur.com/tEzIYe3.png?resize=645%2C402&amp;ssl=1" width="645" height="402"></p>
  <p>With accumulative recursion, however, you build the answer as you go down the staircase. As a result, when you reach the termination step, at the bottom of the staircase, you already have your answer and don’t need to work your way back up again. It&nbsp;<em>accumulates</em> the answer as it works its way to the termination step, hence the name.</p>
  <p>So what would the accumulative answer to the exam question look like? Well, if we want to have a result to be accumulated, then we’ll need a variable that represents that result. And once we have that variable, we’ll want to write the program in such a way so that it will know whether or not to manipulate that variable depending on the given parameters. In our case, we want the list to add the first item in the list to our accumulator if the list is not empty. If the list is empty, then just return whatever the current sum is.</p>
  <p><script src="https://pastebin.com/embed_js/L3q72FLy/noheader"></script><style>		div.embedPastebin { text-align:left; padding: 0; color: #000; margin: 0; font-family: monospace; background: #F7F7F7; border: 1px solid ddd; border-radius:3px; }		div.embedPastebin {  }		div.embedPastebin div.embedFooter { background: #F7F7F7; color: #333; font-size: 100%; padding: 6px 12px; border-bottom: 1px solid #ddd; text-transform:uppercase; }		div.embedPastebin div.embedFooter a,		div.embedPastebin div.embedFooter a:visited { color: #336699; text-decoration:none; }		div.embedPastebin div.embedFooter a:hover { color: red; }		.noLines ol { list-style-type: none; padding-left: 0.5em; }		.embedPastebin{background-color:#F8F8F8;border:1px solid #ddd;font-size:12px;overflow:auto;margin: 0 0 0 0;padding:0 0 0 0;line-height:21px}		.embedPastebin div { line-height:21px; font-family:Consolas, Menlo, Monaco, Lucida Console,'Bitstream Vera Sans Mono','Courier',monospace; }		ol { margin:0; padding: 0 0 0 55px}		ol li { border:0; margin:0;padding:0; }		li.ln-xtra .de1, li.ln-xtra .de2 {background:#F8F8CE;}		.embedPastebin ol li.li1 { margin: 0; }		.embedPastebin ol li.li2 { margin: 0; }.racket .de1, .racket .de2 {-moz-user-select: text;-khtml-user-select: text;-webkit-user-select: text;-ms-user-select: text;user-select: text;margin:0; padding: 0 8px; background:none; vertical-align:top;color:#000;border-left: 1px solid #ddd; margin: 0 0 0 -7px; position: relative; background: #ffffff;}.racket  {color:#ACACAC;}.racket .imp {font-weight: bold; color: red;}.racket li, .racket .li1 {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none;}.racket .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}.racket .kw1 {color: blue;}.racket .kw2 {color: rgb(34, 34, 139);}.racket .kw3 {color: blue;}.racket .kw4 {color: rgb(34, 34, 139);}.racket .co1 {color: rgb(194, 116, 31);}.racket .coMULTI {color: rgb(194, 116, 31);}.racket .br0 {color: rgb(132, 60,36);}.racket .sy0 {color: rgb(132, 60,36);}.racket .st0 {color: rgb(34, 139, 34);}.racket .nu0 {color: rgb(34, 139, 34);}.racket .nu1 {color: rgb(34, 139, 34);}.racket .nu2 {color: rgb(34, 139, 34);}.racket .nu3 {color: rgb(34, 139, 34);}.racket .nu4 {color: rgb(34, 139, 34);}.racket .me0 {color: #202020;}.racket .re1 {color: rgb(34, 139, 34);}.racket .re2 {color: rgb(132, 60,36);}.racket .re3 {color: rgb(34, 139, 34);}.racket .ln-xtra, .racket li.ln-xtra, .racket div.ln-xtra {background:#FFFF88;}.racket span.xtra { display:block; }	</style>	</p><div class="embedPastebin">		<ol class="racket"><li class="li1"><div class="de1">; accumulative-sort: [ListOf Number] -&gt; Number</div></li><li class="li1"><div class="de1">; Calculates the sum of a given list of numbers using accumulative recursion.</div></li><li class="li1"><div class="de1">(define (accumulative-sort lon)</div></li><li class="li1"><div class="de1">&nbsp; (local</div></li><li class="li2"><div class="de2">&nbsp; &nbsp; [(define acc (λ (lon sum)</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cond</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[(empty? lon) sum]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[else (acc (rest lon) (+ (first lon) sum))])))]</div></li><li class="li1"><div class="de1">&nbsp; &nbsp; (acc lon 0)))</div></li><li class="li2"><div class="de2">&nbsp;</div></li><li class="li1"><div class="de1">(check-expect (accumulative-sort empty) 0)</div></li><li class="li1"><div class="de1">(check-expect (accumulative-sort (list 1)) 1)</div></li><li class="li1"><div class="de1">(check-expect (accumulative-sort (list 1 2 3)) 6)</div></li><li class="li1"><div class="de1">(check-expect (accumulative-sort (list 2 4 6 8)) 20)</div></li></ol></div><p></p>
  <p>Looking at the code above, you can see that I ended up creating a local helper function. I’ll explain my reasoning for this later, so let’s just focus on the helper function at the moment. The function takes in a list of numbers and a number and then outputs another number. The list that we want the sum of will be the first argument, and the second parameter will be what we call an accumulator&nbsp;<strong>invariant</strong>, essentially what we will be building on to create our result. Looking at the conditions for the helper function, we can see that if the list is empty, then simply return the&nbsp;invariant&nbsp;<em>sum.&nbsp;</em>Otherwise, recursively call the function again, but the first parameter will be the rest of the list, and we will add the first item in the list to the invariant. By doing so, we create a way of saving what we currently have calculated. We’ll want to start&nbsp;<em>sum</em> at 0 because we haven’t added anything to it yet.</p>
  <p><img class="center" src="https://i2.wp.com/i.imgur.com/RNRuf65.png?resize=611%2C516&amp;ssl=1" width="611" height="516"></p>
  <p>The reason I created a local helper function instead of simply making&nbsp;<em>acc</em> my function is because I wanted&nbsp;<em>accumulator-sum</em> to only have to receive one parameter, a list of numbers.&nbsp;<em>Acc</em> requires two parameters, and because I’ll always want&nbsp;<em>sum</em> to start at 0, I made&nbsp;<em>acc</em> a helper function and then had&nbsp;<em>accumulator-sum</em> call&nbsp;<em>acc</em> with&nbsp;<em>sum&nbsp;</em>already set to 0.</p>
  <br />
  <p>Well, that should just about do it for today’s post. As usual, the full code is below for you to check out yourself. Thank you for reading and have a wonderful day!</p>
  <p><iframe style="border: none; width: 100%; height: 600px;" src="https://pastebin.com/embed_iframe/s8gsWxb4/noheader"></iframe></p>
</div>
